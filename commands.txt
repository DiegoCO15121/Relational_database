pwd stands for "print working directory".
ls stands "list" (to see what's in the folder).
use cd <folder_name> to go into a folder. cd stands for "change directory".
cd .. to return to the previous folder.
You can see what's in a file with "more <filename>".
clear to empty the terminal.    
"ls <flag>" to add a flag to a command to use it different ways. "-l"  (long list format). "-a (show all files, including the hiddden)
"cd ../.. " is used to return two previous folders.
mkdir stands for "make directory".
"touch <filename>" is used to create a new file.
cp <file> <destination> is used to copy files to another folder.
rm <filename> is used to remove a file.
mv <filename> <new_filename>. mv stands for "move", it can rename or move something.
"find" used to find things or view a file tree. 
"mkdir <folder_name>/<new_folder_name>" is used to create a folder into another folder.
"find <folder_name>" is used to display the tree of a different folder.
"find -name <filename>" is used to search for something. 
"rmdir <directory_name>" is used to remove a folder.
"rm -r" is used to remove directories and their contents recursively.
"echo text >> filename" is used to print a text in one file.
"cp -r" is used to copy files/directories recursively.
"sh <file_name>" is used to run a script using the shell interpreter.
"bash <file_name>" is used to run a script with bash interpreter. bash stands for bourne-again shell.
"which bash" this comand is used to find where the bash interpreter is located

//shebang: it used to tell your program to interpreter using
"#!<path_to_interpreter"
// -rw-r--r-- : describe permissions different users have with the file. r means read, w means write x means execute.
"chmod +x questionnaire.sh" give everyone executable permissions.

/////////// The following is done inside the shell-script
-Bash has variables, functions and other things. We can create a variable with "VARIABLE_NAME=VALUE" (withput spaces, If a variable has any spaces 
in it, place double quotes around it).
-To use a variable, place & in front of it like this: "$VARIABLE_NAME" (we can print it using "echo" into script).
-"read VARIABLE_NAME" : this command create a variable that accept input from a user.
-"echo $*" is used in the script to print all arguments passed to it (arguments are passed through the terminal), we can also can specify what 
argument to use with "echo $1" (or any number).

-Sintax for if:
if [[ CONDITION ]]
then
  STATEMENTS
else
  STATEMENTS
fi

-Relational operators: -eq (equal), -ne (not equal), -lt (less than), -le (less than or equal), -gt (greater than), -ge (greater than or equal)
the above syntax is used when using bracket notation. With parenthesis notation no.
"=~" we use it match regular expressions 

-Sintax for:
for (( i = n; i > n2; i-- ))
do
  echo $i
done

-multiline comment:
: '
  comment here
  more comment here
'

-Sintax for while:
while [[ CONDITION ]]
do
  STATEMENTS
done

-Random number: "NUMBER=$(( RANDOM % 75 rm + 1 ))"

-Functions sintaxis:
FUNCTION_NAME() {
  STATEMENTS
}

FUNCTION_CALL "<argument_message>" //Add argunments when we call functions

-Until loop: This loop os very similar to the while loop. It will execute the loop until a condition is met.
until [[ CONDITION ]]
do
  STATEMENTS
done

"man <command>" is another way to find information about commands (man means manual).
"echo -e" is used to enable interpretation of backslash escapes.
"./File_name.sh arg1, arg2, ..." is used to pass arguments to a .sh file.
//Each command has an exit status that can be accessed with "$?". When we type a expresion like "[[ 4 -le 5 ]]" in the termina, we can view the exit status of the last command 
with echo $?.
//We can separate 2 diferents commands on a single line with ";" (example: [[ 10 -ne 5 ]]; echo $?).
"[[ -a file_name ]]; echo $?" return true if file exist.
"[[ -x file_name ]]: echo $?" return true if file is executable by you.
-We use (( I-- )) to subtract one to variable (it can be within the script).
-We use (( I++ )) to add one to varaible (it can be within the script). s
"echo $(( I + 4 ))" is used to make calculations on the terminal (doesn't change the value of the variable).
"ARR=("a" "b" "c")" is used to create an array.
"echo ${ARR[1]}" is used to print to the terminal a specific position in the array (also we can use * to print all positions).
"type <command>" Display information about command type.

"cat <file_name>" is used to print the contents of a file
IFS = Internal Field Separator. The variable is used to dtermine word boundaries. It defaults to spaces, tabs, and new lines.
'PSQL="psql -X --username=freecodecamp --dbname=students --no-align --tuples-only -c"' This allow you to query your database from your script.
"$($PSQL "<query_here>")" Way to use PSQL varable.
"cp <file_name> <new_file_name>" is used to create another file with the same content of original file.

"[[ -z $<variable> ]]" is an "if" that checks if a variable is empety.

"<command> > <filename>" redirects the command ouput to a file. if we use a single ">", a new file will be created; with ">>" the command will be appended.
//There’s two types of output, stdout (standard out) for when a command is successful, and stderr (standard error) for when it’s not.
With "2>" we can print the type stderr output to a file.
With "1>" we can print the type stdout output to a file (is the same as ">").
//stdin (standard in) is the third thing commands can use and is for getting input.
"<command> < <filename_for_stdin>" redirects the command ipunt to a file.
//Another way to set the stdin is by using the pipe (|). It will use the output from one command as input for another. Here's an example: <command_1> | <command_2>. 
This will take the stdout from command_1 and use it as the stdin for command_2.  it run the command in a subshell or subprocess. it won't affect the variables previous set.
//wc
"wc <file_name>" Stands for word count. It showed you how many lines were in the file, how many words, and how many bytes.
"-l" this flag is used to know how many lines are in the file, "-w" to words, "-m" to characters.
//grep
"grep '<pattern>' <filename>" is used to search for patterns in text.
grep '<pattern1>|<pattern2>'
"--color"flag is used to highlight matching words.
"-n" flag is used to show all the line numbers where matching words.
"-c" flag is used to get a count of lines where matching words.
"-o" flag give you each match on it's own line.
//sed
sed 's/<pattern_to_replace>/<text_to_replace_it_with>/' <filename> is used to repalce text. After the last '/' we can add regex flags like: 'g' for global & 'i' to ignore the case of the pattern
"-r" is a flag to sed, it extended a regular expression (example:sed 's/[0-9]+/1/' won't detect '+' but sed -r 's/[0-9]+/1/' will detect )
"sed 's/<pattern_1>/<replacement_1>/; s/<pattern_2>/<replacement_2>/'" (replace many patterns)
//diff
"diff <file_1> <file_2>." is used to view the difference between two files.

-Sintax for case:
case EXPRESSION in
  PATTERN) STATEMENTS ;;
  PATTERN) STATEMENTS ;;
  PATTERN) STATEMENTS ;;
  *) STATEMENTS ;;
esac

//Sintax for subshell (it usually use for PSQL commands)
VARIABLE=$(<command>)